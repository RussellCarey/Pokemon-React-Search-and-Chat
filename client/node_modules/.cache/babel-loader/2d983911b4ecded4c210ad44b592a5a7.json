{"ast":null,"code":"/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\nclass CanvasImage {\n  constructor(image) {\n    this.removeCanvas = function () {\n      this.canvas.parentNode.removeChild(this.canvas);\n    };\n\n    this.canvas = document.createElement(\"canvas\");\n    this.context = this.canvas.getContext(\"2d\");\n    document.body.appendChild(this.canvas);\n    this.width = this.canvas.width = image.width;\n    this.height = this.canvas.height = image.height;\n    this.context.drawImage(image, 0, 0, this.width, this.height);\n  }\n\n  clear() {\n    this.context.clearRect(0, 0, this.width, this.height);\n  }\n\n  update(imageData) {\n    this.context.putImageData(imageData, 0, 0);\n  }\n\n  getPixelCount() {\n    return this.width * this.height;\n  }\n\n  getImageData() {\n    return this.context.getImageData(0, 0, this.width, this.height);\n  }\n\n}\n\nexport default class ColorThief {\n  convertColorRgb(values) {\n    if (!values.length) return value;\n    if (!values[0].length) return `rgb(${values[0]}, ${values[1]}, ${values[2]})`;\n    return values.reduce(function (result, value) {\n      if (!value.length) return result;\n      result.push(`rgb(${value[0]}, ${value[1]}, ${value[2]})`);\n      return result;\n    }, []);\n  } //TODO convertColorHex\n\n  /*\n   * getColor(sourceImage[, quality])\n   * returns [r(num), g(num), b(num)]\n   *\n   * Use the median cut algorithm provided by quantize.js to cluster similar\n   * colors and return the base color from the largest cluster.\n   *\n   * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n   * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n   * faster a color will be returned but the greater the likelihood that it will not be the visually\n   * most dominant color.\n   * */\n\n\n  getColor(sourceImage, quality) {\n    var palette = this.getPalette(sourceImage, 5, quality);\n    var dominantColor = palette[0];\n    return dominantColor;\n  }\n  /*\n   * getPalette(sourceImage[, colorCount, quality])\n   * returns array[ [r(num), g(num), b(num)], [r(num), g(num), b(num)], ...]\n   *\n   * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n   *\n   * colorCount determines the size of the palette; the number of colors returned. If not set, it\n   * defaults to 10.\n   *\n   * BUGGY: Function does not always return the requested amount of colors. It can be +/- 2.\n   *\n   * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n   * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n   * faster the palette generation but the greater the likelihood that colors will be missed.\n   */\n\n\n  getPalette(sourceImage, colorCount, quality) {\n    if (typeof colorCount === \"undefined\" || colorCount < 2 || colorCount > 256) {\n      colorCount = 10;\n    }\n\n    if (typeof quality === \"undefined\" || quality < 1) {\n      quality = 10;\n    } // Create custom CanvasImage object\n\n\n    const image = new CanvasImage(sourceImage);\n    const imageData = image.getImageData();\n    const pixels = imageData.data;\n    const pixelCount = image.getPixelCount(); // Store the RGB values in an array format suitable for quantize function\n\n    const pixelArray = [];\n\n    for (let i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n      offset = i * 4;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3]; // If pixel is mostly opaque and not white\n\n      if (a >= 125) {\n        if (!(r > 250 && g > 250 && b > 250)) {\n          pixelArray.push([r, g, b]);\n        }\n      }\n    } // Send array to quantize function which clusters values\n    // using median cut algorithm\n\n\n    const cmap = MMCQ.quantize(pixelArray, colorCount);\n    const palette = cmap ? cmap.palette() : []; // Clean up\n\n    image.removeCanvas();\n    return palette;\n  }\n\n  getColorFromUrl(imageUrl, quality) {\n    const sourceImage = document.createElement(\"img\");\n    const thief = this;\n    return new Promise(function (resolve) {\n      sourceImage.addEventListener(\"load\", function () {\n        const palette = thief.getPalette(sourceImage, 5, quality);\n        const dominantColor = palette[0];\n        resolve(dominantColor);\n      });\n      sourceImage.src = imageUrl;\n    });\n  }\n\n  getImageData(imageUrl) {\n    return new Promise(function (resolve) {\n      const xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", imageUrl, true);\n      xhr.responseType = \"arraybuffer\";\n\n      xhr.onload = function (e) {\n        if (this.status == 200) {\n          const uInt8Array = new Uint8Array(this.response);\n          const i = uInt8Array.length;\n          const binaryString = new Array(i);\n\n          for (let i = 0; i < uInt8Array.length; i++) {\n            binaryString[i] = String.fromCharCode(uInt8Array[i]);\n          }\n\n          const data = binaryString.join(\"\");\n          const base64 = window.btoa(data);\n          resolve(\"data:image/png;base64,\" + base64);\n        }\n      };\n\n      xhr.send();\n    });\n  }\n\n  getColorAsync(imageUrl, quality) {\n    const thief = this;\n    return this.getImageData(imageUrl).then(function (imageData) {\n      return thief.getColorFromUrl(imageData, quality);\n    });\n  }\n\n}\n/*!\n * quantize.js Copyright 2008 Nick Rabinowitz.\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n * @license\n */\n// fill out a couple protovis dependencies\n\n/*!\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n * @license\n */\n\nif (!pv) {\n  var pv = {\n    map: function (array, f) {\n      var o = {};\n      return f ? array.map(function (d, i) {\n        o.index = i;\n        return f.call(o, d);\n      }) : array.slice();\n    },\n    naturalOrder: function (a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    },\n    sum: function (array, f) {\n      var o = {};\n      return array.reduce(f ? function (p, d, i) {\n        o.index = i;\n        return p + f.call(o, d);\n      } : function (p, d) {\n        return p + d;\n      }, 0);\n    },\n    max: function (array, f) {\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\n    }\n  };\n}\n/**\n* Basic Javascript port of the MMCQ (modified median cut quantization)\n* algorithm from the Leptonica library (http://www.leptonica.com/).\n* Returns a color map you can use to map original pixels to the reduced\n* palette. Still a work in progress.\n*\n* @author Nick Rabinowitz\n* @example\n\n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n              // etc\n              ];\nvar maxColors = 4;\n\nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) {\n  return cmap.map(p);\n});\n\n*/\n\n\nvar MMCQ = function () {\n  // private constants\n  var sigbits = 5,\n      rshift = 8 - sigbits,\n      maxIterations = 1000,\n      fractByPopulations = 0.75; // get reduced-space color index for a pixel\n\n  function getColorIndex(r, g, b) {\n    return (r << 2 * sigbits) + (g << sigbits) + b;\n  } // Simple priority queue\n\n\n  function PQueue(comparator) {\n    var contents = [],\n        sorted = false;\n\n    function sort() {\n      contents.sort(comparator);\n      sorted = true;\n    }\n\n    return {\n      push: function (o) {\n        contents.push(o);\n        sorted = false;\n      },\n      peek: function (index) {\n        if (!sorted) sort();\n        if (index === undefined) index = contents.length - 1;\n        return contents[index];\n      },\n      pop: function () {\n        if (!sorted) sort();\n        return contents.pop();\n      },\n      size: function () {\n        return contents.length;\n      },\n      map: function (f) {\n        return contents.map(f);\n      },\n      debug: function () {\n        if (!sorted) sort();\n        return contents;\n      }\n    };\n  } // 3d color space box\n\n\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\n    var vbox = this;\n    vbox.r1 = r1;\n    vbox.r2 = r2;\n    vbox.g1 = g1;\n    vbox.g2 = g2;\n    vbox.b1 = b1;\n    vbox.b2 = b2;\n    vbox.histo = histo;\n  }\n\n  VBox.prototype = {\n    volume: function (force) {\n      var vbox = this;\n\n      if (!vbox._volume || force) {\n        vbox._volume = (vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1);\n      }\n\n      return vbox._volume;\n    },\n    count: function (force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._count_set || force) {\n        var npix = 0,\n            index,\n            i,\n            j,\n            k;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              index = getColorIndex(i, j, k);\n              npix += histo[index] || 0;\n            }\n          }\n        }\n\n        vbox._count = npix;\n        vbox._count_set = true;\n      }\n\n      return vbox._count;\n    },\n    copy: function () {\n      var vbox = this;\n      return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n    },\n    avg: function (force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._avg || force) {\n        var ntot = 0,\n            mult = 1 << 8 - sigbits,\n            rsum = 0,\n            gsum = 0,\n            bsum = 0,\n            hval,\n            i,\n            j,\n            k,\n            histoindex;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              histoindex = getColorIndex(i, j, k);\n              hval = histo[histoindex] || 0;\n              ntot += hval;\n              rsum += hval * (i + 0.5) * mult;\n              gsum += hval * (j + 0.5) * mult;\n              bsum += hval * (k + 0.5) * mult;\n            }\n          }\n        }\n\n        if (ntot) {\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n        } else {\n          //                    console.log('empty box');\n          vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n        }\n      }\n\n      return vbox._avg;\n    },\n    contains: function (pixel) {\n      var vbox = this,\n          rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      return rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && gval <= vbox.g2 && bval >= vbox.b1 && bval <= vbox.b2;\n    }\n  }; // Color map\n\n  function CMap() {\n    this.vboxes = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());\n    });\n  }\n\n  CMap.prototype = {\n    push: function (vbox) {\n      this.vboxes.push({\n        vbox: vbox,\n        color: vbox.avg()\n      });\n    },\n    palette: function () {\n      return this.vboxes.map(function (vb) {\n        return vb.color;\n      });\n    },\n    size: function () {\n      return this.vboxes.size();\n    },\n    map: function (color) {\n      var vboxes = this.vboxes;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        if (vboxes.peek(i).vbox.contains(color)) {\n          return vboxes.peek(i).color;\n        }\n      }\n\n      return this.nearest(color);\n    },\n    nearest: function (color) {\n      var vboxes = this.vboxes,\n          d1,\n          d2,\n          pColor;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));\n\n        if (d2 < d1 || d1 === undefined) {\n          d1 = d2;\n          pColor = vboxes.peek(i).color;\n        }\n      }\n\n      return pColor;\n    },\n    forcebw: function () {\n      // XXX: won't  work yet\n      var vboxes = this.vboxes;\n      vboxes.sort(function (a, b) {\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));\n      }); // force darkest color to black if everything < 5\n\n      var lowest = vboxes[0].color;\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5) vboxes[0].color = [0, 0, 0]; // force lightest color to white if everything > 251\n\n      var idx = vboxes.length - 1,\n          highest = vboxes[idx].color;\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) vboxes[idx].color = [255, 255, 255];\n    }\n  }; // histo (1-d array, giving the number of pixels in\n  // each quantized region of color space), or null on error\n\n  function getHisto(pixels) {\n    var histosize = 1 << 3 * sigbits,\n        histo = new Array(histosize),\n        index,\n        rval,\n        gval,\n        bval;\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      index = getColorIndex(rval, gval, bval);\n      histo[index] = (histo[index] || 0) + 1;\n    });\n    return histo;\n  }\n\n  function vboxFromPixels(pixels, histo) {\n    var rmin = 1000000,\n        rmax = 0,\n        gmin = 1000000,\n        gmax = 0,\n        bmin = 1000000,\n        bmax = 0,\n        rval,\n        gval,\n        bval; // find min/max\n\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      if (rval < rmin) rmin = rval;else if (rval > rmax) rmax = rval;\n      if (gval < gmin) gmin = gval;else if (gval > gmax) gmax = gval;\n      if (bval < bmin) bmin = bval;else if (bval > bmax) bmax = bval;\n    });\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n  }\n\n  function medianCutApply(histo, vbox) {\n    if (!vbox.count()) return;\n    var rw = vbox.r2 - vbox.r1 + 1,\n        gw = vbox.g2 - vbox.g1 + 1,\n        bw = vbox.b2 - vbox.b1 + 1,\n        maxw = pv.max([rw, gw, bw]); // only one pixel, no split\n\n    if (vbox.count() == 1) {\n      return [vbox.copy()];\n    }\n    /* Find the partial sum arrays along the selected axis. */\n\n\n    var total = 0,\n        partialsum = [],\n        lookaheadsum = [],\n        i,\n        j,\n        k,\n        sum,\n        index;\n\n    if (maxw == rw) {\n      for (i = vbox.r1; i <= vbox.r2; i++) {\n        sum = 0;\n\n        for (j = vbox.g1; j <= vbox.g2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(i, j, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else if (maxw == gw) {\n      for (i = vbox.g1; i <= vbox.g2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(j, i, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else {\n      /* maxw == bw */\n      for (i = vbox.b1; i <= vbox.b2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.g1; k <= vbox.g2; k++) {\n            index = getColorIndex(j, k, i);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    }\n\n    partialsum.forEach(function (d, i) {\n      lookaheadsum[i] = total - d;\n    });\n\n    function doCut(color) {\n      var dim1 = color + \"1\",\n          dim2 = color + \"2\",\n          left,\n          right,\n          vbox1,\n          vbox2,\n          d2,\n          count2 = 0;\n\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n        if (partialsum[i] > total / 2) {\n          vbox1 = vbox.copy();\n          vbox2 = vbox.copy();\n          left = i - vbox[dim1];\n          right = vbox[dim2] - i;\n          if (left <= right) d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2)); // avoid 0-count boxes\n\n          while (!partialsum[d2]) d2++;\n\n          count2 = lookaheadsum[d2];\n\n          while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2]; // set dimensions\n\n\n          vbox1[dim2] = d2;\n          vbox2[dim1] = vbox1[dim2] + 1; //                    console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n\n          return [vbox1, vbox2];\n        }\n      }\n    } // determine the cut planes\n\n\n    return maxw == rw ? doCut(\"r\") : maxw == gw ? doCut(\"g\") : doCut(\"b\");\n  }\n\n  function quantize(pixels, maxcolors) {\n    // short-circuit\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n      //            console.log('wrong number of maxcolors');\n      return false;\n    } // XXX: check color content and convert to grayscale if insufficient\n\n\n    var histo = getHisto(pixels),\n        histosize = 1 << 3 * sigbits; // check that we aren't below maxcolors already\n\n    var nColors = 0;\n    histo.forEach(function () {\n      nColors++;\n    });\n\n    if (nColors <= maxcolors) {// XXX: generate the new colors from the histo and return\n    } // get the beginning vbox from the colors\n\n\n    var vbox = vboxFromPixels(pixels, histo),\n        pq = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count(), b.count());\n    });\n    pq.push(vbox); // inner function to do the iteration\n\n    function iter(lh, target) {\n      var ncolors = 1,\n          niters = 0,\n          vbox;\n\n      while (niters < maxIterations) {\n        vbox = lh.pop();\n\n        if (!vbox.count()) {\n          /* just put it back */\n          lh.push(vbox);\n          niters++;\n          continue;\n        } // do the cut\n\n\n        var vboxes = medianCutApply(histo, vbox),\n            vbox1 = vboxes[0],\n            vbox2 = vboxes[1];\n\n        if (!vbox1) {\n          //                    console.log(\"vbox1 not defined; shouldn't happen!\");\n          return;\n        }\n\n        lh.push(vbox1);\n\n        if (vbox2) {\n          /* vbox2 can be null */\n          lh.push(vbox2);\n          ncolors++;\n        }\n\n        if (ncolors >= target) return;\n\n        if (niters++ > maxIterations) {\n          //                    console.log(\"infinite loop; perhaps too few pixels!\");\n          return;\n        }\n      }\n    } // first set of colors, sorted by population\n\n\n    iter(pq, fractByPopulations * maxcolors); // Re-sort by the product of pixel occupancy times the size in color space.\n\n    var pq2 = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n    });\n\n    while (pq.size()) {\n      pq2.push(pq.pop());\n    } // next set - generate the median cuts using the (npix * vol) sorting.\n\n\n    iter(pq2, maxcolors - pq2.size()); // calculate the actual colors\n\n    var cmap = new CMap();\n\n    while (pq2.size()) {\n      cmap.push(pq2.pop());\n    }\n\n    return cmap;\n  }\n\n  return {\n    quantize: quantize\n  };\n}();","map":{"version":3,"sources":["/Users/r/Desktop/React/MY PROJECTS/pokesimple/src/utils/ColorThief.js"],"names":["CanvasImage","constructor","image","removeCanvas","canvas","parentNode","removeChild","document","createElement","context","getContext","body","appendChild","width","height","drawImage","clear","clearRect","update","imageData","putImageData","getPixelCount","getImageData","ColorThief","convertColorRgb","values","length","value","reduce","result","push","getColor","sourceImage","quality","palette","getPalette","dominantColor","colorCount","pixels","data","pixelCount","pixelArray","i","offset","r","g","b","a","cmap","MMCQ","quantize","getColorFromUrl","imageUrl","thief","Promise","resolve","addEventListener","src","xhr","XMLHttpRequest","open","responseType","onload","e","status","uInt8Array","Uint8Array","response","binaryString","Array","String","fromCharCode","join","base64","window","btoa","send","getColorAsync","then","pv","map","array","f","o","d","index","call","slice","naturalOrder","sum","p","max","Math","apply","sigbits","rshift","maxIterations","fractByPopulations","getColorIndex","PQueue","comparator","contents","sorted","sort","peek","undefined","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","vbox","prototype","volume","force","_volume","count","_count_set","npix","j","k","_count","copy","avg","_avg","ntot","mult","rsum","gsum","bsum","hval","histoindex","contains","pixel","rval","gval","bval","CMap","vboxes","color","vb","nearest","d1","d2","pColor","sqrt","pow","forcebw","lowest","idx","highest","getHisto","histosize","forEach","vboxFromPixels","rmin","rmax","gmin","gmax","bmin","bmax","medianCutApply","rw","gw","bw","maxw","total","partialsum","lookaheadsum","doCut","dim1","dim2","left","right","vbox1","vbox2","count2","min","maxcolors","nColors","pq","iter","lh","target","ncolors","niters","pq2"],"mappings":"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","sourcesContent":["/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\nclass CanvasImage {\n  constructor(image) {\n    this.canvas = document.createElement(\"canvas\");\n    this.context = this.canvas.getContext(\"2d\");\n\n    document.body.appendChild(this.canvas);\n\n    this.width = this.canvas.width = image.width;\n    this.height = this.canvas.height = image.height;\n\n    this.context.drawImage(image, 0, 0, this.width, this.height);\n  }\n\n  clear() {\n    this.context.clearRect(0, 0, this.width, this.height);\n  }\n\n  update(imageData) {\n    this.context.putImageData(imageData, 0, 0);\n  }\n\n  getPixelCount() {\n    return this.width * this.height;\n  }\n\n  getImageData() {\n    return this.context.getImageData(0, 0, this.width, this.height);\n  }\n\n  removeCanvas = function () {\n    this.canvas.parentNode.removeChild(this.canvas);\n  };\n}\n\nexport default class ColorThief {\n  convertColorRgb(values) {\n    if (!values.length) return value;\n\n    if (!values[0].length)\n      return `rgb(${values[0]}, ${values[1]}, ${values[2]})`;\n\n    return values.reduce(function (result, value) {\n      if (!value.length) return result;\n\n      result.push(`rgb(${value[0]}, ${value[1]}, ${value[2]})`);\n      return result;\n    }, []);\n  }\n\n  //TODO convertColorHex\n\n  /*\n   * getColor(sourceImage[, quality])\n   * returns [r(num), g(num), b(num)]\n   *\n   * Use the median cut algorithm provided by quantize.js to cluster similar\n   * colors and return the base color from the largest cluster.\n   *\n   * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n   * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n   * faster a color will be returned but the greater the likelihood that it will not be the visually\n   * most dominant color.\n   * */\n  getColor(sourceImage, quality) {\n    var palette = this.getPalette(sourceImage, 5, quality);\n    var dominantColor = palette[0];\n    return dominantColor;\n  }\n\n  /*\n   * getPalette(sourceImage[, colorCount, quality])\n   * returns array[ [r(num), g(num), b(num)], [r(num), g(num), b(num)], ...]\n   *\n   * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n   *\n   * colorCount determines the size of the palette; the number of colors returned. If not set, it\n   * defaults to 10.\n   *\n   * BUGGY: Function does not always return the requested amount of colors. It can be +/- 2.\n   *\n   * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n   * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n   * faster the palette generation but the greater the likelihood that colors will be missed.\n   */\n  getPalette(sourceImage, colorCount, quality) {\n    if (\n      typeof colorCount === \"undefined\" ||\n      colorCount < 2 ||\n      colorCount > 256\n    ) {\n      colorCount = 10;\n    }\n    if (typeof quality === \"undefined\" || quality < 1) {\n      quality = 10;\n    }\n\n    // Create custom CanvasImage object\n    const image = new CanvasImage(sourceImage);\n    const imageData = image.getImageData();\n    const pixels = imageData.data;\n    const pixelCount = image.getPixelCount();\n\n    // Store the RGB values in an array format suitable for quantize function\n    const pixelArray = [];\n    for (let i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n      offset = i * 4;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      // If pixel is mostly opaque and not white\n      if (a >= 125) {\n        if (!(r > 250 && g > 250 && b > 250)) {\n          pixelArray.push([r, g, b]);\n        }\n      }\n    }\n\n    // Send array to quantize function which clusters values\n    // using median cut algorithm\n    const cmap = MMCQ.quantize(pixelArray, colorCount);\n    const palette = cmap ? cmap.palette() : [];\n\n    // Clean up\n    image.removeCanvas();\n\n    return palette;\n  }\n\n  getColorFromUrl(imageUrl, quality) {\n    const sourceImage = document.createElement(\"img\");\n    const thief = this;\n\n    return new Promise(function (resolve) {\n      sourceImage.addEventListener(\"load\", function () {\n        const palette = thief.getPalette(sourceImage, 5, quality);\n        const dominantColor = palette[0];\n        resolve(dominantColor);\n      });\n      sourceImage.src = imageUrl;\n    });\n  }\n\n  getImageData(imageUrl) {\n    return new Promise(function (resolve) {\n      const xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", imageUrl, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = function (e) {\n        if (this.status == 200) {\n          const uInt8Array = new Uint8Array(this.response);\n          const i = uInt8Array.length;\n          const binaryString = new Array(i);\n          for (let i = 0; i < uInt8Array.length; i++) {\n            binaryString[i] = String.fromCharCode(uInt8Array[i]);\n          }\n          const data = binaryString.join(\"\");\n          const base64 = window.btoa(data);\n          resolve(\"data:image/png;base64,\" + base64);\n        }\n      };\n      xhr.send();\n    });\n  }\n\n  getColorAsync(imageUrl, quality) {\n    const thief = this;\n    return this.getImageData(imageUrl).then(function (imageData) {\n      return thief.getColorFromUrl(imageData, quality);\n    });\n  }\n}\n\n/*!\n * quantize.js Copyright 2008 Nick Rabinowitz.\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n * @license\n */\n\n// fill out a couple protovis dependencies\n/*!\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n * @license\n */\nif (!pv) {\n  var pv = {\n    map: function (array, f) {\n      var o = {};\n      return f\n        ? array.map(function (d, i) {\n            o.index = i;\n            return f.call(o, d);\n          })\n        : array.slice();\n    },\n    naturalOrder: function (a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    },\n    sum: function (array, f) {\n      var o = {};\n      return array.reduce(\n        f\n          ? function (p, d, i) {\n              o.index = i;\n              return p + f.call(o, d);\n            }\n          : function (p, d) {\n              return p + d;\n            },\n        0\n      );\n    },\n    max: function (array, f) {\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\n    },\n  };\n}\n\n/**\n* Basic Javascript port of the MMCQ (modified median cut quantization)\n* algorithm from the Leptonica library (http://www.leptonica.com/).\n* Returns a color map you can use to map original pixels to the reduced\n* palette. Still a work in progress.\n*\n* @author Nick Rabinowitz\n* @example\n\n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n              // etc\n              ];\nvar maxColors = 4;\n\nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) {\n  return cmap.map(p);\n});\n\n*/\nvar MMCQ = (function () {\n  // private constants\n  var sigbits = 5,\n    rshift = 8 - sigbits,\n    maxIterations = 1000,\n    fractByPopulations = 0.75;\n\n  // get reduced-space color index for a pixel\n  function getColorIndex(r, g, b) {\n    return (r << (2 * sigbits)) + (g << sigbits) + b;\n  }\n\n  // Simple priority queue\n  function PQueue(comparator) {\n    var contents = [],\n      sorted = false;\n\n    function sort() {\n      contents.sort(comparator);\n      sorted = true;\n    }\n\n    return {\n      push: function (o) {\n        contents.push(o);\n        sorted = false;\n      },\n      peek: function (index) {\n        if (!sorted) sort();\n        if (index === undefined) index = contents.length - 1;\n        return contents[index];\n      },\n      pop: function () {\n        if (!sorted) sort();\n        return contents.pop();\n      },\n      size: function () {\n        return contents.length;\n      },\n      map: function (f) {\n        return contents.map(f);\n      },\n      debug: function () {\n        if (!sorted) sort();\n        return contents;\n      },\n    };\n  }\n\n  // 3d color space box\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\n    var vbox = this;\n    vbox.r1 = r1;\n    vbox.r2 = r2;\n    vbox.g1 = g1;\n    vbox.g2 = g2;\n    vbox.b1 = b1;\n    vbox.b2 = b2;\n    vbox.histo = histo;\n  }\n  VBox.prototype = {\n    volume: function (force) {\n      var vbox = this;\n      if (!vbox._volume || force) {\n        vbox._volume =\n          (vbox.r2 - vbox.r1 + 1) *\n          (vbox.g2 - vbox.g1 + 1) *\n          (vbox.b2 - vbox.b1 + 1);\n      }\n      return vbox._volume;\n    },\n    count: function (force) {\n      var vbox = this,\n        histo = vbox.histo;\n      if (!vbox._count_set || force) {\n        var npix = 0,\n          index,\n          i,\n          j,\n          k;\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              index = getColorIndex(i, j, k);\n              npix += histo[index] || 0;\n            }\n          }\n        }\n        vbox._count = npix;\n        vbox._count_set = true;\n      }\n      return vbox._count;\n    },\n    copy: function () {\n      var vbox = this;\n      return new VBox(\n        vbox.r1,\n        vbox.r2,\n        vbox.g1,\n        vbox.g2,\n        vbox.b1,\n        vbox.b2,\n        vbox.histo\n      );\n    },\n    avg: function (force) {\n      var vbox = this,\n        histo = vbox.histo;\n      if (!vbox._avg || force) {\n        var ntot = 0,\n          mult = 1 << (8 - sigbits),\n          rsum = 0,\n          gsum = 0,\n          bsum = 0,\n          hval,\n          i,\n          j,\n          k,\n          histoindex;\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              histoindex = getColorIndex(i, j, k);\n              hval = histo[histoindex] || 0;\n              ntot += hval;\n              rsum += hval * (i + 0.5) * mult;\n              gsum += hval * (j + 0.5) * mult;\n              bsum += hval * (k + 0.5) * mult;\n            }\n          }\n        }\n        if (ntot) {\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n        } else {\n          //                    console.log('empty box');\n          vbox._avg = [\n            ~~((mult * (vbox.r1 + vbox.r2 + 1)) / 2),\n            ~~((mult * (vbox.g1 + vbox.g2 + 1)) / 2),\n            ~~((mult * (vbox.b1 + vbox.b2 + 1)) / 2),\n          ];\n        }\n      }\n      return vbox._avg;\n    },\n    contains: function (pixel) {\n      var vbox = this,\n        rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      return (\n        rval >= vbox.r1 &&\n        rval <= vbox.r2 &&\n        gval >= vbox.g1 &&\n        gval <= vbox.g2 &&\n        bval >= vbox.b1 &&\n        bval <= vbox.b2\n      );\n    },\n  };\n\n  // Color map\n  function CMap() {\n    this.vboxes = new PQueue(function (a, b) {\n      return pv.naturalOrder(\n        a.vbox.count() * a.vbox.volume(),\n        b.vbox.count() * b.vbox.volume()\n      );\n    });\n  }\n  CMap.prototype = {\n    push: function (vbox) {\n      this.vboxes.push({\n        vbox: vbox,\n        color: vbox.avg(),\n      });\n    },\n    palette: function () {\n      return this.vboxes.map(function (vb) {\n        return vb.color;\n      });\n    },\n    size: function () {\n      return this.vboxes.size();\n    },\n    map: function (color) {\n      var vboxes = this.vboxes;\n      for (var i = 0; i < vboxes.size(); i++) {\n        if (vboxes.peek(i).vbox.contains(color)) {\n          return vboxes.peek(i).color;\n        }\n      }\n      return this.nearest(color);\n    },\n    nearest: function (color) {\n      var vboxes = this.vboxes,\n        d1,\n        d2,\n        pColor;\n      for (var i = 0; i < vboxes.size(); i++) {\n        d2 = Math.sqrt(\n          Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n            Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n            Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n        );\n        if (d2 < d1 || d1 === undefined) {\n          d1 = d2;\n          pColor = vboxes.peek(i).color;\n        }\n      }\n      return pColor;\n    },\n    forcebw: function () {\n      // XXX: won't  work yet\n      var vboxes = this.vboxes;\n      vboxes.sort(function (a, b) {\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));\n      });\n\n      // force darkest color to black if everything < 5\n      var lowest = vboxes[0].color;\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n        vboxes[0].color = [0, 0, 0];\n\n      // force lightest color to white if everything > 251\n      var idx = vboxes.length - 1,\n        highest = vboxes[idx].color;\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n        vboxes[idx].color = [255, 255, 255];\n    },\n  };\n\n  // histo (1-d array, giving the number of pixels in\n  // each quantized region of color space), or null on error\n  function getHisto(pixels) {\n    var histosize = 1 << (3 * sigbits),\n      histo = new Array(histosize),\n      index,\n      rval,\n      gval,\n      bval;\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      index = getColorIndex(rval, gval, bval);\n      histo[index] = (histo[index] || 0) + 1;\n    });\n    return histo;\n  }\n\n  function vboxFromPixels(pixels, histo) {\n    var rmin = 1000000,\n      rmax = 0,\n      gmin = 1000000,\n      gmax = 0,\n      bmin = 1000000,\n      bmax = 0,\n      rval,\n      gval,\n      bval;\n    // find min/max\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      if (rval < rmin) rmin = rval;\n      else if (rval > rmax) rmax = rval;\n      if (gval < gmin) gmin = gval;\n      else if (gval > gmax) gmax = gval;\n      if (bval < bmin) bmin = bval;\n      else if (bval > bmax) bmax = bval;\n    });\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n  }\n\n  function medianCutApply(histo, vbox) {\n    if (!vbox.count()) return;\n\n    var rw = vbox.r2 - vbox.r1 + 1,\n      gw = vbox.g2 - vbox.g1 + 1,\n      bw = vbox.b2 - vbox.b1 + 1,\n      maxw = pv.max([rw, gw, bw]);\n    // only one pixel, no split\n    if (vbox.count() == 1) {\n      return [vbox.copy()];\n    }\n    /* Find the partial sum arrays along the selected axis. */\n    var total = 0,\n      partialsum = [],\n      lookaheadsum = [],\n      i,\n      j,\n      k,\n      sum,\n      index;\n    if (maxw == rw) {\n      for (i = vbox.r1; i <= vbox.r2; i++) {\n        sum = 0;\n        for (j = vbox.g1; j <= vbox.g2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(i, j, k);\n            sum += histo[index] || 0;\n          }\n        }\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else if (maxw == gw) {\n      for (i = vbox.g1; i <= vbox.g2; i++) {\n        sum = 0;\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(j, i, k);\n            sum += histo[index] || 0;\n          }\n        }\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else {\n      /* maxw == bw */\n      for (i = vbox.b1; i <= vbox.b2; i++) {\n        sum = 0;\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.g1; k <= vbox.g2; k++) {\n            index = getColorIndex(j, k, i);\n            sum += histo[index] || 0;\n          }\n        }\n        total += sum;\n        partialsum[i] = total;\n      }\n    }\n    partialsum.forEach(function (d, i) {\n      lookaheadsum[i] = total - d;\n    });\n    function doCut(color) {\n      var dim1 = color + \"1\",\n        dim2 = color + \"2\",\n        left,\n        right,\n        vbox1,\n        vbox2,\n        d2,\n        count2 = 0;\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n        if (partialsum[i] > total / 2) {\n          vbox1 = vbox.copy();\n          vbox2 = vbox.copy();\n          left = i - vbox[dim1];\n          right = vbox[dim2] - i;\n          if (left <= right) d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));\n          else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\n          // avoid 0-count boxes\n          while (!partialsum[d2]) d2++;\n          count2 = lookaheadsum[d2];\n          while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n          // set dimensions\n          vbox1[dim2] = d2;\n          vbox2[dim1] = vbox1[dim2] + 1;\n          //                    console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n          return [vbox1, vbox2];\n        }\n      }\n    }\n    // determine the cut planes\n    return maxw == rw ? doCut(\"r\") : maxw == gw ? doCut(\"g\") : doCut(\"b\");\n  }\n\n  function quantize(pixels, maxcolors) {\n    // short-circuit\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n      //            console.log('wrong number of maxcolors');\n      return false;\n    }\n\n    // XXX: check color content and convert to grayscale if insufficient\n\n    var histo = getHisto(pixels),\n      histosize = 1 << (3 * sigbits);\n\n    // check that we aren't below maxcolors already\n    var nColors = 0;\n    histo.forEach(function () {\n      nColors++;\n    });\n    if (nColors <= maxcolors) {\n      // XXX: generate the new colors from the histo and return\n    }\n\n    // get the beginning vbox from the colors\n    var vbox = vboxFromPixels(pixels, histo),\n      pq = new PQueue(function (a, b) {\n        return pv.naturalOrder(a.count(), b.count());\n      });\n    pq.push(vbox);\n\n    // inner function to do the iteration\n    function iter(lh, target) {\n      var ncolors = 1,\n        niters = 0,\n        vbox;\n      while (niters < maxIterations) {\n        vbox = lh.pop();\n        if (!vbox.count()) {\n          /* just put it back */\n          lh.push(vbox);\n          niters++;\n          continue;\n        }\n        // do the cut\n        var vboxes = medianCutApply(histo, vbox),\n          vbox1 = vboxes[0],\n          vbox2 = vboxes[1];\n\n        if (!vbox1) {\n          //                    console.log(\"vbox1 not defined; shouldn't happen!\");\n          return;\n        }\n        lh.push(vbox1);\n        if (vbox2) {\n          /* vbox2 can be null */\n          lh.push(vbox2);\n          ncolors++;\n        }\n        if (ncolors >= target) return;\n        if (niters++ > maxIterations) {\n          //                    console.log(\"infinite loop; perhaps too few pixels!\");\n          return;\n        }\n      }\n    }\n\n    // first set of colors, sorted by population\n    iter(pq, fractByPopulations * maxcolors);\n\n    // Re-sort by the product of pixel occupancy times the size in color space.\n    var pq2 = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n    });\n    while (pq.size()) {\n      pq2.push(pq.pop());\n    }\n\n    // next set - generate the median cuts using the (npix * vol) sorting.\n    iter(pq2, maxcolors - pq2.size());\n\n    // calculate the actual colors\n    var cmap = new CMap();\n    while (pq2.size()) {\n      cmap.push(pq2.pop());\n    }\n\n    return cmap;\n  }\n\n  return {\n    quantize: quantize,\n  };\n})();\n"]},"metadata":{},"sourceType":"module"}